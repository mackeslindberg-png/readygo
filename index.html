<!doctype html>
<html lang="sv">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>Ready Go</title>

<style>
html,body{margin:0;padding:0;min-height:100%;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif}
body{
  background: radial-gradient(circle at 30% 10%, rgba(30,30,30,1), rgba(0,0,0,1));
  display:flex;align-items:center;justify-content:center;
  padding:16px;
}

/* App-rutan */
.card{
  width:100%;max-width:520px;
  border-radius:16px;
  padding:16px;
  box-shadow:0 12px 30px rgba(0,0,0,.45);

  /* Bakgrund inne i rutan */
  background-image: url("bg.png");
  background-size: cover;
  background-position: center;

  position: relative;
  overflow: hidden;
}

/* Transparens/tint ovanpå bakgrund */
.card::before{
  content:"";
  position:absolute;
  inset:0;
  background: rgba(255,255,255,.78); /* justera transparens här */
  pointer-events:none;
}

/* Innehåll över overlay */
.card > *{ position: relative; }

h1{margin:0 0 12px 0}
.row{margin:12px 0}
label{display:flex;gap:10px;align-items:center}
select,button{width:100%;padding:12px;font-size:16px;border-radius:12px}
select{border:1px solid rgba(0,0,0,.15);background:#fff}
button{border:none;font-weight:800;cursor:pointer}
.start{background:#111;color:#fff}
.stop{background:#b00020;color:#fff}
.status{margin-top:10px;font-weight:800}
.small{font-size:13px;color:#222;line-height:1.35}
.pill{display:inline-block;padding:2px 8px;border:1px solid rgba(0,0,0,.15);border-radius:999px;font-size:12px;background:rgba(255,255,255,.7)}
</style>
</head>

<body>
<div class="card">
  <h1>Ready Go</h1>

  <div class="row">
    <label>Röstläge</label>
    <select id="mode">
      <option value="fast">Snabb</option>
      <option value="mid">Mellan</option>
      <option value="slow">Långsam</option>
    </select>
  </div>

  <div class="row">
    <label><input type="checkbox" id="shuffle"> Shuffle röstläge</label>
  </div>

  <div class="row">
    <label>Startfördröjning</label>
    <label><input type="radio" name="delay" value="2-4" checked> 2–4 sek</label>
    <label><input type="radio" name="delay" value="3-6"> 3–6 sek</label>
  </div>

  <div class="row">
    <label><input type="checkbox" id="repeat"> Repetera (3–6 sek)</label>
  </div>

  <div class="status" id="status">Status: redo <span class="pill" id="diag">redo</span></div>

  <div class="row">
    <button id="btn" class="start">START</button>
  </div>

  <div class="small">
    MP3-läge. Mindre "chipmunk": alla lägen använder samma taltempo som "Mellan".
    Snabb och långsam styrs främst av pauslängd men håller total-tiderna 0,5s / 1,0s / 1,5s.
  </div>
</div>

<script>
const FILES = {
  ready: "ready.mp3",
  go: "go.mp3"
};

// Total tid (Ready + paus + Go)
const TARGET_SECONDS = {
  fast: 0.50,
  mid:  1.00,
  slow: 1.50
};

let ctx = null;
let buffers = { ready:null, go:null };
let running = false;
let timer = null;
let session = 0;

const btn = document.getElementById("btn");
const statusEl = document.getElementById("status");
const diagEl = document.getElementById("diag");

function setStatus(t){ statusEl.firstChild.textContent = "Status: " + t + " "; }
function setDiag(t){ diagEl.textContent = t; }
function rand(min,max){ return Math.floor(Math.random()*(max-min+1))+min; }
function wait(ms){ return new Promise(r=>setTimeout(r,ms)); }

function pickMode(){
  const shuffle = document.getElementById("shuffle").checked;
  const selected = document.getElementById("mode").value;
  if (!shuffle) return selected;
  return ["fast","mid","slow"][rand(0,2)];
}

function delayWindowMs(){
  const d = document.querySelector('input[name="delay"]:checked').value;
  return d==="2-4" ? rand(2000,4000) : rand(3000,6000);
}
function repeatGapMs(){ return rand(3000,6000); }

function ensureCtx(){
  if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
  return ctx;
}

async function fetchDecode(url){
  const r = await fetch(url, { cache:"no-store" });
  if (!r.ok) throw new Error("404: " + url);
  const arr = await r.arrayBuffer();
  return await ensureCtx().decodeAudioData(arr);
}

async function ensureAudio(){
  const c = ensureCtx();
  if (c.state !== "running") await c.resume();

  if (!buffers.ready || !buffers.go){
    setDiag("laddar ljud…");
    buffers.ready = await fetchDecode(FILES.ready);
    buffers.go    = await fetchDecode(FILES.go);
    setDiag("redo");
  }
}

function playBuffer(buf, rate=1.0){
  return new Promise(resolve=>{
    const src = ctx.createBufferSource();
    src.buffer = buf;
    src.playbackRate.value = rate;
    src.connect(ctx.destination);
    src.onended = resolve;
    src.start(0);
  });
}

function modeLabel(mode){
  if (mode === "fast") return "snabb";
  if (mode === "mid") return "mellan";
  return "långsam";
}

/**
 * Ny logik (mindre chipmunk):
 * 1) Räkna fram ett "naturligt" rateMid som träffar mellan-läget (1,0s) med en liten paus.
 * 2) Använd samma rateMid i ALLA lägen.
 * 3) Snabb/långsam uppnås med paus så att totalen blir 0,5s resp 1,5s.
 *
 * OBS: Om 0,5s är fysiskt omöjligt med rateMid (filernas längd för lång),
 * så kommer pausen bli 0 och snabb blir "så snabb det går" med samma tempo som mellan.
 */
function computeParams(mode){
  const durReady = buffers.ready.duration;
  const durGo = buffers.go.duration;
  const sumDur = durReady + durGo;

  // 1) Hitta rateMid
  const targetMid = TARGET_SECONDS.mid; // 1.00s

  // liten standardpaus i mellan
  let midPauseSec = Math.min(0.18, Math.max(0.02, targetMid * 0.08));
  let midAvail = targetMid - midPauseSec;
  if (midAvail <= 0.05){ midPauseSec = 0; midAvail = targetMid; }

  let rateMid = sumDur / midAvail;

  // rimliga gränser
  const MIN_RATE = 0.40;
  const MAX_RATE = 6.00;

  // om för hög rate, ta bort paus och räkna om
  if (rateMid > MAX_RATE){
    midPauseSec = 0;
    rateMid = sumDur / targetMid;
  }
  rateMid = Math.max(MIN_RATE, Math.min(MAX_RATE, rateMid));

  // 2) Sätt pause per mode för att nå target med samma rateMid
  const target = TARGET_SECONDS[mode];
  let pauseSec = target - (sumDur / rateMid);

  // clampa paus
  pauseSec = Math.max(0, pauseSec);
  pauseSec = Math.min(5.0, pauseSec);

  // Special: i mid vill vi behålla den "lilla naturliga" pausen om möjligt
  // men fortfarande prio att träffa 1.0s totalt
  if (mode === "mid"){
    // om den räknade pausen är extremt liten, använd standard
    // annars använd exakt för att träffa totalen
    // (vi tar exakt pausen, men begränsar den lite)
    // lämna som den är (exact pauseSec), men om 0 så lägg liten paus
    if (pauseSec === 0) pauseSec = midPauseSec;
  }

  return {
    rate: rateMid,
    pauseMs: Math.round(pauseSec * 1000),
    target,
    rateMid
  };
}

async function speakOnce(mySession){
  if (!running || mySession !== session) return;

  const mode = pickMode();
  setStatus(modeLabel(mode));

  const { rate, pauseMs, target } = computeParams(mode);

  setDiag(`${modeLabel(mode)} ${target.toFixed(2)}s · rate ${rate.toFixed(2)} · paus ${pauseMs}ms`);

  await playBuffer(buffers.ready, rate);
  if (pauseMs > 0) await wait(pauseMs);
  await playBuffer(buffers.go, rate);
}

async function loop(mySession){
  if (!running || mySession !== session) return;

  try {
    await speakOnce(mySession);
  } catch {
    setDiag("fel");
    stop();
    return;
  }

  if (!running || mySession !== session) return;

  if (!document.getElementById("repeat").checked){
    stop();
    return;
  }

  const gap = repeatGapMs();
  setStatus("väntar " + Math.round(gap/1000) + " s");
  timer = setTimeout(()=>loop(mySession), gap);
}

function stop(){
  running = false;
  clearTimeout(timer);
  timer = null;
  btn.textContent = "START";
  btn.className = "start";
  setStatus("redo");
  setDiag("redo");
}

async function start(){
  running = true;
  session++;
  const mySession = session;

  btn.textContent = "STOPP";
  btn.className = "stop";

  try {
    await ensureAudio();
  } catch {
    setDiag("blockerad");
    stop();
    return;
  }

  const w = delayWindowMs();
  setStatus("start om " + Math.round(w/1000) + " s");
  clearTimeout(timer);
  timer = setTimeout(()=>loop(mySession), w);
}

btn.onclick = () => running ? stop() : start();
document.addEventListener("visibilitychange", ()=>document.hidden && running && stop());
</script>
</body>
</html>
